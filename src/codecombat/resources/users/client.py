# This file was auto-generated by Fern from our API Definition.

import typing
import urllib.parse
from json.decoder import JSONDecodeError

import pydantic

from ...core.api_error import ApiError
from ...core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ...core.jsonable_encoder import jsonable_encoder
from ...core.remove_none_from_dict import remove_none_from_dict
from ...types.classroom_response_with_code import ClassroomResponseWithCode
from ...types.datetime_string import DatetimeString
from ...types.object_id_string import ObjectIdString
from ...types.user_response import UserResponse
from ...types.users_create_request_hero_config import UsersCreateRequestHeroConfig
from ...types.users_create_request_role import UsersCreateRequestRole

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class UsersClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def create(
        self,
        *,
        name: str,
        email: str,
        role: typing.Optional[UsersCreateRequestRole] = OMIT,
        preferred_language: typing.Optional[str] = OMIT,
        hero_config: typing.Optional[UsersCreateRequestHeroConfig] = OMIT,
        birthday: typing.Optional[str] = OMIT,
    ) -> UserResponse:
        """
        Creates a `User`.

        Parameters:
            - name: str.

            - email: str.

            - role: typing.Optional[UsersCreateRequestRole]. `"student"` or `"teacher"`. If unset, a home user will be created, unable to join classrooms.

            - preferred_language: typing.Optional[str].

            - hero_config: typing.Optional[UsersCreateRequestHeroConfig].

            - birthday: typing.Optional[str].
        """
        _request: typing.Dict[str, typing.Any] = {"name": name, "email": email}
        if role is not OMIT:
            _request["role"] = role
        if preferred_language is not OMIT:
            _request["preferredLanguage"] = preferred_language
        if hero_config is not OMIT:
            _request["heroConfig"] = hero_config
        if birthday is not OMIT:
            _request["birthday"] = birthday
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "users"),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(UserResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get(self, handle: str, *, include_play_time: typing.Optional[str] = None) -> UserResponse:
        """
        Returns a `User`.

        Parameters:
            - handle: str. The document's `_id` or `slug`.

            - include_play_time: typing.Optional[str]. Set to non-empty string to include stats.playTime in response
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"users/{handle}"),
            params=remove_none_from_dict({"includePlayTime": include_play_time}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(UserResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def update(self, handle: str, *, name: str, birthday: typing.Optional[str] = OMIT) -> UserResponse:
        """
        Modify name of a `User`

        Parameters:
            - handle: str. The document's `_id` or `slug`.

            - name: str. Set to new name string

            - birthday: typing.Optional[str]. Set the birthday
        """
        _request: typing.Dict[str, typing.Any] = {"name": name}
        if birthday is not OMIT:
            _request["birthday"] = birthday
        _response = self._client_wrapper.httpx_client.request(
            "PUT",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"users/{handle}"),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(UserResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_classrooms(
        self, handle: str, *, ret_member_limit: typing.Optional[float] = None
    ) -> typing.List[ClassroomResponseWithCode]:
        """
        Returns a list of `Classrooms` this user is in (if a student) or owns (if a teacher).

        Parameters:
            - handle: str. The document's `_id` or `slug`.

            - ret_member_limit: typing.Optional[float]. limit the return number of members for each classroom
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"users/{handle}/classrooms"),
            params=remove_none_from_dict({"retMemberLimit": ret_member_limit}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[ClassroomResponseWithCode], _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def set_hero(self, handle: str, *, thang_type: typing.Optional[ObjectIdString] = OMIT) -> UserResponse:
        """
        Set the user's hero.

        Parameters:
            - handle: str. The document's `_id` or `slug`.

            - thang_type: typing.Optional[ObjectIdString].
        """
        _request: typing.Dict[str, typing.Any] = {}
        if thang_type is not OMIT:
            _request["thangType"] = thang_type
        _response = self._client_wrapper.httpx_client.request(
            "PUT",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"users/{handle}/hero-config"),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(UserResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def set_ace_config(
        self,
        handle: str,
        *,
        live_completion: typing.Optional[bool] = OMIT,
        behaviors: typing.Optional[bool] = OMIT,
        language: typing.Optional[str] = OMIT,
    ) -> UserResponse:
        """
        Set the user's aceConfig (the settings for the in-game Ace code editor), such as whether to enable autocomplete.

        Parameters:
            - handle: str. The document's `_id` or `slug`.

            - live_completion: typing.Optional[bool]. controls whether autocompletion snippets show up, the default value is true

            - behaviors: typing.Optional[bool]. controls whether things like automatic parenthesis and quote completion happens, the default value is false

            - language: typing.Optional[str]. only for home users, should be one of ["python", "javascript", "cpp", "lua", "coffeescript"] right now
        """
        _request: typing.Dict[str, typing.Any] = {}
        if live_completion is not OMIT:
            _request["liveCompletion"] = live_completion
        if behaviors is not OMIT:
            _request["behaviors"] = behaviors
        if language is not OMIT:
            _request["language"] = language
        _response = self._client_wrapper.httpx_client.request(
            "PUT",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"users/{handle}/ace-config"),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(UserResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def grant_premium_subscription(self, handle: str, *, ends: DatetimeString) -> UserResponse:
        """
        Grants a user premium access to the "Home" version up to a certain time.

        Parameters:
            - handle: str. The document's `_id` or `slug`.

            - ends: DatetimeString.
        """
        _response = self._client_wrapper.httpx_client.request(
            "PUT",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"users/{handle}/subscription"),
            json=jsonable_encoder({"ends": ends}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(UserResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def shorten_subscription(self, handle: str, *, ends: DatetimeString) -> UserResponse:
        """
        If the user already has a premium access up to a certain time, this shortens/revokes his/her premium access. If the ends is less than or equal to the current time, it revokes the subscription and sets the end date to be the current time, else it just shortens the subscription.

        Parameters:
            - handle: str. The document's `_id` or `slug`.

            - ends: DatetimeString.
        """
        _response = self._client_wrapper.httpx_client.request(
            "PUT",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"users/{handle}/shorten-subscription"),
            json=jsonable_encoder({"ends": ends}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(UserResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def grant_license(self, handle: str, *, ends: DatetimeString) -> UserResponse:
        """
        Grants a user access to the "Classroom" version up to a certain time.
        Sets their role to "student".

        Parameters:
            - handle: str. The document's `_id` or `slug`.

            - ends: DatetimeString.
        """
        _response = self._client_wrapper.httpx_client.request(
            "PUT",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"users/{handle}/license"),
            json=jsonable_encoder({"ends": ends}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(UserResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def shorten_license(self, handle: str, *, ends: DatetimeString) -> UserResponse:
        """
        If the user already has access to the "Classroom" version up to a certain time, this shortens/revokes his/her access. If the ends is less than or equal to the current time, it revokes the enrollment and sets the end date to be the current time, else it just shortens the enrollment.

        Parameters:
            - handle: str. The document's `_id` or `slug`.

            - ends: DatetimeString.
        """
        _response = self._client_wrapper.httpx_client.request(
            "PUT",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"users/{handle}/shorten-license"),
            json=jsonable_encoder({"ends": ends}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(UserResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def lookup(self, property: str, value: str) -> None:
        """
        Redirects to `/users/{handle}` given a unique, identifying property

        Parameters:
            - property: str. The property to lookup by. May either be `"israel-id"` or `"name"`.

            - value: str. The value to be looked up.
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"user-lookup/{property}/{value}"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)


class AsyncUsersClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def create(
        self,
        *,
        name: str,
        email: str,
        role: typing.Optional[UsersCreateRequestRole] = OMIT,
        preferred_language: typing.Optional[str] = OMIT,
        hero_config: typing.Optional[UsersCreateRequestHeroConfig] = OMIT,
        birthday: typing.Optional[str] = OMIT,
    ) -> UserResponse:
        """
        Creates a `User`.

        Parameters:
            - name: str.

            - email: str.

            - role: typing.Optional[UsersCreateRequestRole]. `"student"` or `"teacher"`. If unset, a home user will be created, unable to join classrooms.

            - preferred_language: typing.Optional[str].

            - hero_config: typing.Optional[UsersCreateRequestHeroConfig].

            - birthday: typing.Optional[str].
        """
        _request: typing.Dict[str, typing.Any] = {"name": name, "email": email}
        if role is not OMIT:
            _request["role"] = role
        if preferred_language is not OMIT:
            _request["preferredLanguage"] = preferred_language
        if hero_config is not OMIT:
            _request["heroConfig"] = hero_config
        if birthday is not OMIT:
            _request["birthday"] = birthday
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "users"),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(UserResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get(self, handle: str, *, include_play_time: typing.Optional[str] = None) -> UserResponse:
        """
        Returns a `User`.

        Parameters:
            - handle: str. The document's `_id` or `slug`.

            - include_play_time: typing.Optional[str]. Set to non-empty string to include stats.playTime in response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"users/{handle}"),
            params=remove_none_from_dict({"includePlayTime": include_play_time}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(UserResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def update(self, handle: str, *, name: str, birthday: typing.Optional[str] = OMIT) -> UserResponse:
        """
        Modify name of a `User`

        Parameters:
            - handle: str. The document's `_id` or `slug`.

            - name: str. Set to new name string

            - birthday: typing.Optional[str]. Set the birthday
        """
        _request: typing.Dict[str, typing.Any] = {"name": name}
        if birthday is not OMIT:
            _request["birthday"] = birthday
        _response = await self._client_wrapper.httpx_client.request(
            "PUT",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"users/{handle}"),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(UserResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_classrooms(
        self, handle: str, *, ret_member_limit: typing.Optional[float] = None
    ) -> typing.List[ClassroomResponseWithCode]:
        """
        Returns a list of `Classrooms` this user is in (if a student) or owns (if a teacher).

        Parameters:
            - handle: str. The document's `_id` or `slug`.

            - ret_member_limit: typing.Optional[float]. limit the return number of members for each classroom
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"users/{handle}/classrooms"),
            params=remove_none_from_dict({"retMemberLimit": ret_member_limit}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[ClassroomResponseWithCode], _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def set_hero(self, handle: str, *, thang_type: typing.Optional[ObjectIdString] = OMIT) -> UserResponse:
        """
        Set the user's hero.

        Parameters:
            - handle: str. The document's `_id` or `slug`.

            - thang_type: typing.Optional[ObjectIdString].
        """
        _request: typing.Dict[str, typing.Any] = {}
        if thang_type is not OMIT:
            _request["thangType"] = thang_type
        _response = await self._client_wrapper.httpx_client.request(
            "PUT",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"users/{handle}/hero-config"),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(UserResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def set_ace_config(
        self,
        handle: str,
        *,
        live_completion: typing.Optional[bool] = OMIT,
        behaviors: typing.Optional[bool] = OMIT,
        language: typing.Optional[str] = OMIT,
    ) -> UserResponse:
        """
        Set the user's aceConfig (the settings for the in-game Ace code editor), such as whether to enable autocomplete.

        Parameters:
            - handle: str. The document's `_id` or `slug`.

            - live_completion: typing.Optional[bool]. controls whether autocompletion snippets show up, the default value is true

            - behaviors: typing.Optional[bool]. controls whether things like automatic parenthesis and quote completion happens, the default value is false

            - language: typing.Optional[str]. only for home users, should be one of ["python", "javascript", "cpp", "lua", "coffeescript"] right now
        """
        _request: typing.Dict[str, typing.Any] = {}
        if live_completion is not OMIT:
            _request["liveCompletion"] = live_completion
        if behaviors is not OMIT:
            _request["behaviors"] = behaviors
        if language is not OMIT:
            _request["language"] = language
        _response = await self._client_wrapper.httpx_client.request(
            "PUT",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"users/{handle}/ace-config"),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(UserResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def grant_premium_subscription(self, handle: str, *, ends: DatetimeString) -> UserResponse:
        """
        Grants a user premium access to the "Home" version up to a certain time.

        Parameters:
            - handle: str. The document's `_id` or `slug`.

            - ends: DatetimeString.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "PUT",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"users/{handle}/subscription"),
            json=jsonable_encoder({"ends": ends}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(UserResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def shorten_subscription(self, handle: str, *, ends: DatetimeString) -> UserResponse:
        """
        If the user already has a premium access up to a certain time, this shortens/revokes his/her premium access. If the ends is less than or equal to the current time, it revokes the subscription and sets the end date to be the current time, else it just shortens the subscription.

        Parameters:
            - handle: str. The document's `_id` or `slug`.

            - ends: DatetimeString.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "PUT",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"users/{handle}/shorten-subscription"),
            json=jsonable_encoder({"ends": ends}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(UserResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def grant_license(self, handle: str, *, ends: DatetimeString) -> UserResponse:
        """
        Grants a user access to the "Classroom" version up to a certain time.
        Sets their role to "student".

        Parameters:
            - handle: str. The document's `_id` or `slug`.

            - ends: DatetimeString.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "PUT",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"users/{handle}/license"),
            json=jsonable_encoder({"ends": ends}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(UserResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def shorten_license(self, handle: str, *, ends: DatetimeString) -> UserResponse:
        """
        If the user already has access to the "Classroom" version up to a certain time, this shortens/revokes his/her access. If the ends is less than or equal to the current time, it revokes the enrollment and sets the end date to be the current time, else it just shortens the enrollment.

        Parameters:
            - handle: str. The document's `_id` or `slug`.

            - ends: DatetimeString.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "PUT",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"users/{handle}/shorten-license"),
            json=jsonable_encoder({"ends": ends}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(UserResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def lookup(self, property: str, value: str) -> None:
        """
        Redirects to `/users/{handle}` given a unique, identifying property

        Parameters:
            - property: str. The property to lookup by. May either be `"israel-id"` or `"name"`.

            - value: str. The value to be looked up.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"user-lookup/{property}/{value}"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)
