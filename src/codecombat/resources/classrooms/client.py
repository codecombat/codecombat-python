# This file was auto-generated by Fern from our API Definition.

import typing
import urllib.parse
from json.decoder import JSONDecodeError

import pydantic

from ...core.api_error import ApiError
from ...core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ...core.jsonable_encoder import jsonable_encoder
from ...core.remove_none_from_dict import remove_none_from_dict
from ...types.classroom_response import ClassroomResponse
from ...types.classroom_response_with_code import ClassroomResponseWithCode
from ...types.classrooms_create_request_ace_config import ClassroomsCreateRequestAceConfig
from ...types.classrooms_get_members_stats_response_item import ClassroomsGetMembersStatsResponseItem
from ...types.level_session_response import LevelSessionResponse
from ...types.object_id_string import ObjectIdString

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class ClassroomsClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def get(self, *, code: str, ret_member_limit: typing.Optional[float] = None) -> ClassroomResponseWithCode:
        """
        Returns the classroom details for a class code.

        Parameters:
            - code: str. The classroom's `code`.

            - ret_member_limit: typing.Optional[float]. limit the return number of members for the classroom
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "classrooms"),
            params=remove_none_from_dict({"code": code, "retMemberLimit": ret_member_limit}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ClassroomResponseWithCode, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def create(
        self, *, name: str, owner_id: ObjectIdString, ace_config: ClassroomsCreateRequestAceConfig
    ) -> ClassroomResponseWithCode:
        """
        Creates a new empty `Classroom`.

        Parameters:
            - name: str. Name of the classroom

            - owner_id: ObjectIdString.

            - ace_config: ClassroomsCreateRequestAceConfig.
        """
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "classrooms"),
            json=jsonable_encoder({"name": name, "ownerID": owner_id, "aceConfig": ace_config}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ClassroomResponseWithCode, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def upsert_member(
        self, handle: str, *, code: str, user_id: str, ret_member_limit: typing.Optional[float] = OMIT
    ) -> ClassroomResponse:
        """
        Upserts a user into the classroom.

        Parameters:
            - handle: str. The document's `_id` or `slug`.

            - code: str. The code for joining this classroom

            - user_id: str. The `_id` or `slug` of the user to add to the class.

            - ret_member_limit: typing.Optional[float]. limit the return number of members for the classroom, the default value is 1000
        """
        _request: typing.Dict[str, typing.Any] = {"code": code, "userId": user_id}
        if ret_member_limit is not OMIT:
            _request["retMemberLimit"] = ret_member_limit
        _response = self._client_wrapper.httpx_client.request(
            "PUT",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"classrooms/{handle}/members"),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ClassroomResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def remove_member(
        self, handle: str, *, user_id: str, ret_member_limit: typing.Optional[float] = OMIT
    ) -> ClassroomResponse:
        """
        Remove a user from the classroom.

        Parameters:
            - handle: str. The document's `_id` or `slug`.

            - user_id: str. The `_id` or `slug` of the user to remove from the class.

            - ret_member_limit: typing.Optional[float]. limit the return number of members for the classroom, the default value is 1000
        """
        _request: typing.Dict[str, typing.Any] = {"userId": user_id}
        if ret_member_limit is not OMIT:
            _request["retMemberLimit"] = ret_member_limit
        _response = self._client_wrapper.httpx_client.request(
            "DELETE",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"classrooms/{handle}/members"),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ClassroomResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def enroll_user_in_course(
        self,
        classroom_handle: str,
        course_handle: str,
        *,
        ret_member_limit: typing.Optional[float] = None,
        user_id: ObjectIdString,
    ) -> ClassroomResponse:
        """
        Enrolls a user in a course in a classroom.
        If the course is paid, user must have an active license.
        User must be a member of the classroom.

        Parameters:
            - classroom_handle: str. The classroom's `_id`.

            - course_handle: str. The course's `_id`.

            - ret_member_limit: typing.Optional[float]. limit the return number of members for the classroom, the default value is 1000

            - user_id: ObjectIdString.
        """
        _response = self._client_wrapper.httpx_client.request(
            "PUT",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"classrooms/{classroom_handle}/courses/{course_handle}/enrolled",
            ),
            params=remove_none_from_dict({"retMemberLimit": ret_member_limit}),
            json=jsonable_encoder({"userId": user_id}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ClassroomResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def remove_enrolled_user(
        self,
        classroom_handle: str,
        course_handle: str,
        *,
        ret_member_limit: typing.Optional[float] = None,
        user_id: ObjectIdString,
    ) -> ClassroomResponse:
        """
        Removes an enrolled user from a course in a classroom.

        Parameters:
            - classroom_handle: str. The classroom's `_id`.

            - course_handle: str. The course's `_id`.

            - ret_member_limit: typing.Optional[float]. limit the return number of members for the classroom, the default value is 1000

            - user_id: ObjectIdString.
        """
        _response = self._client_wrapper.httpx_client.request(
            "PUT",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"classrooms/{classroom_handle}/courses/{course_handle}/remove-enrolled",
            ),
            params=remove_none_from_dict({"retMemberLimit": ret_member_limit}),
            json=jsonable_encoder({"userId": user_id}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ClassroomResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_members_stats(
        self,
        classroom_handle: str,
        *,
        project: typing.Optional[str] = None,
        member_limit: typing.Optional[float] = None,
        member_skip: typing.Optional[float] = None,
    ) -> typing.List[ClassroomsGetMembersStatsResponseItem]:
        """
        Returns a list of all members stats for the classroom.

        Parameters:
            - classroom_handle: str. The classroom's `_id`.

            - project: typing.Optional[str]. If specified, include only the specified projection of returned stats; else, return all stats. Format as a comma-separated list, like `creator,playtime,state.complete`.

            - member_limit: typing.Optional[float]. Limit the return member number. the default value is 10, and the max value is 100

            - member_skip: typing.Optional[float]. Skip the members that doesn't need to return, for pagination

        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"classrooms/{classroom_handle}/stats"),
            params=remove_none_from_dict({"project": project, "memberLimit": member_limit, "memberSkip": member_skip}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[ClassroomsGetMembersStatsResponseItem], _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_levels_played(self, classroom_handle: str, member_handle: str) -> typing.List[LevelSessionResponse]:
        """
        Returns a list of all levels played by the user for the classroom.

        Parameters:
            - classroom_handle: str. The classroom's `_id`.

            - member_handle: str. The classroom member's `_id`.
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"classrooms/{classroom_handle}/members/{member_handle}/sessions",
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[LevelSessionResponse], _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)


class AsyncClassroomsClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def get(self, *, code: str, ret_member_limit: typing.Optional[float] = None) -> ClassroomResponseWithCode:
        """
        Returns the classroom details for a class code.

        Parameters:
            - code: str. The classroom's `code`.

            - ret_member_limit: typing.Optional[float]. limit the return number of members for the classroom
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "classrooms"),
            params=remove_none_from_dict({"code": code, "retMemberLimit": ret_member_limit}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ClassroomResponseWithCode, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def create(
        self, *, name: str, owner_id: ObjectIdString, ace_config: ClassroomsCreateRequestAceConfig
    ) -> ClassroomResponseWithCode:
        """
        Creates a new empty `Classroom`.

        Parameters:
            - name: str. Name of the classroom

            - owner_id: ObjectIdString.

            - ace_config: ClassroomsCreateRequestAceConfig.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "classrooms"),
            json=jsonable_encoder({"name": name, "ownerID": owner_id, "aceConfig": ace_config}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ClassroomResponseWithCode, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def upsert_member(
        self, handle: str, *, code: str, user_id: str, ret_member_limit: typing.Optional[float] = OMIT
    ) -> ClassroomResponse:
        """
        Upserts a user into the classroom.

        Parameters:
            - handle: str. The document's `_id` or `slug`.

            - code: str. The code for joining this classroom

            - user_id: str. The `_id` or `slug` of the user to add to the class.

            - ret_member_limit: typing.Optional[float]. limit the return number of members for the classroom, the default value is 1000
        """
        _request: typing.Dict[str, typing.Any] = {"code": code, "userId": user_id}
        if ret_member_limit is not OMIT:
            _request["retMemberLimit"] = ret_member_limit
        _response = await self._client_wrapper.httpx_client.request(
            "PUT",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"classrooms/{handle}/members"),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ClassroomResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def remove_member(
        self, handle: str, *, user_id: str, ret_member_limit: typing.Optional[float] = OMIT
    ) -> ClassroomResponse:
        """
        Remove a user from the classroom.

        Parameters:
            - handle: str. The document's `_id` or `slug`.

            - user_id: str. The `_id` or `slug` of the user to remove from the class.

            - ret_member_limit: typing.Optional[float]. limit the return number of members for the classroom, the default value is 1000
        """
        _request: typing.Dict[str, typing.Any] = {"userId": user_id}
        if ret_member_limit is not OMIT:
            _request["retMemberLimit"] = ret_member_limit
        _response = await self._client_wrapper.httpx_client.request(
            "DELETE",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"classrooms/{handle}/members"),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ClassroomResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def enroll_user_in_course(
        self,
        classroom_handle: str,
        course_handle: str,
        *,
        ret_member_limit: typing.Optional[float] = None,
        user_id: ObjectIdString,
    ) -> ClassroomResponse:
        """
        Enrolls a user in a course in a classroom.
        If the course is paid, user must have an active license.
        User must be a member of the classroom.

        Parameters:
            - classroom_handle: str. The classroom's `_id`.

            - course_handle: str. The course's `_id`.

            - ret_member_limit: typing.Optional[float]. limit the return number of members for the classroom, the default value is 1000

            - user_id: ObjectIdString.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "PUT",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"classrooms/{classroom_handle}/courses/{course_handle}/enrolled",
            ),
            params=remove_none_from_dict({"retMemberLimit": ret_member_limit}),
            json=jsonable_encoder({"userId": user_id}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ClassroomResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def remove_enrolled_user(
        self,
        classroom_handle: str,
        course_handle: str,
        *,
        ret_member_limit: typing.Optional[float] = None,
        user_id: ObjectIdString,
    ) -> ClassroomResponse:
        """
        Removes an enrolled user from a course in a classroom.

        Parameters:
            - classroom_handle: str. The classroom's `_id`.

            - course_handle: str. The course's `_id`.

            - ret_member_limit: typing.Optional[float]. limit the return number of members for the classroom, the default value is 1000

            - user_id: ObjectIdString.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "PUT",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"classrooms/{classroom_handle}/courses/{course_handle}/remove-enrolled",
            ),
            params=remove_none_from_dict({"retMemberLimit": ret_member_limit}),
            json=jsonable_encoder({"userId": user_id}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ClassroomResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_members_stats(
        self,
        classroom_handle: str,
        *,
        project: typing.Optional[str] = None,
        member_limit: typing.Optional[float] = None,
        member_skip: typing.Optional[float] = None,
    ) -> typing.List[ClassroomsGetMembersStatsResponseItem]:
        """
        Returns a list of all members stats for the classroom.

        Parameters:
            - classroom_handle: str. The classroom's `_id`.

            - project: typing.Optional[str]. If specified, include only the specified projection of returned stats; else, return all stats. Format as a comma-separated list, like `creator,playtime,state.complete`.

            - member_limit: typing.Optional[float]. Limit the return member number. the default value is 10, and the max value is 100

            - member_skip: typing.Optional[float]. Skip the members that doesn't need to return, for pagination

        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"classrooms/{classroom_handle}/stats"),
            params=remove_none_from_dict({"project": project, "memberLimit": member_limit, "memberSkip": member_skip}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[ClassroomsGetMembersStatsResponseItem], _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_levels_played(self, classroom_handle: str, member_handle: str) -> typing.List[LevelSessionResponse]:
        """
        Returns a list of all levels played by the user for the classroom.

        Parameters:
            - classroom_handle: str. The classroom's `_id`.

            - member_handle: str. The classroom member's `_id`.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"classrooms/{classroom_handle}/members/{member_handle}/sessions",
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[LevelSessionResponse], _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)
