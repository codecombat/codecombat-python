# This file was auto-generated by Fern from our API Definition.

import typing
import urllib.parse
from json.decoder import JSONDecodeError

import httpx
import pydantic

from .core.api_error import ApiError
from .core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from .core.jsonable_encoder import jsonable_encoder
from .environment import CodeCombatEnvironment
from .resources.auth.client import AsyncAuthClient, AuthClient
from .resources.clans.client import AsyncClansClient, ClansClient
from .resources.classrooms.client import AsyncClassroomsClient, ClassroomsClient
from .resources.stats.client import AsyncStatsClient, StatsClient
from .resources.users.client import AsyncUsersClient, UsersClient
from .types.user_response import UserResponse

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class CodeCombat:
    def __init__(
        self,
        *,
        base_url: typing.Optional[str] = None,
        environment: CodeCombatEnvironment = CodeCombatEnvironment.DEFAULT,
        username: typing.Union[str, typing.Callable[[], str]],
        password: typing.Union[str, typing.Callable[[], str]],
        timeout: typing.Optional[float] = 60,
    ):
        self._client_wrapper = SyncClientWrapper(
            base_url=_get_base_url(base_url=base_url, environment=environment),
            username=username,
            password=password,
            httpx_client=httpx.Client(timeout=timeout),
        )
        self.auth = AuthClient(client_wrapper=self._client_wrapper)
        self.clans = ClansClient(client_wrapper=self._client_wrapper)
        self.classrooms = ClassroomsClient(client_wrapper=self._client_wrapper)
        self.stats = StatsClient(client_wrapper=self._client_wrapper)
        self.users = UsersClient(client_wrapper=self._client_wrapper)

    def post_users_handle_o_auth_identities(
        self,
        handle: str,
        *,
        provider: str,
        access_token: typing.Optional[str] = OMIT,
        code: typing.Optional[str] = OMIT,
    ) -> UserResponse:
        """
        Adds an OAuth2 identity to the user, so that they can be logged in with that identity. You need to send the OAuth code or the access token to this endpoint. 1. If no access token is provided, it will use your OAuth2 token URL to exchange the given code for an access token. 2. Then it will use the access token (given by you, or received from step 1) to look up the user on your service using the lookup URL, and expects a JSON object in response with an `id` property. 3. It will then save that user `id` to the user in our db as a new OAuthIdentity. In this example, we call your lookup URL (let's say, `https://oauth.provider/user?t=<%= accessToken %>`) with the access token (`1234`). The lookup URL returns `{ id: 'abcd' }` in this case, which we save to the user in our db.

        Parameters:
            - handle: str. The document's `_id` or `slug`.

            - provider: str. Your OAuth Provider ID.

            - access_token: typing.Optional[str]. Will be passed through your lookup URL to get the user ID. Required if no `code`.

            - code: typing.Optional[str]. Will be passed to the OAuth token endpoint to get a token. Required if no `accessToken`.
        """
        _request: typing.Dict[str, typing.Any] = {"provider": provider}
        if access_token is not OMIT:
            _request["accessToken"] = access_token
        if code is not OMIT:
            _request["code"] = code
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"users/{handle}/o-auth-identities"),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(UserResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)


class AsyncCodeCombat:
    def __init__(
        self,
        *,
        base_url: typing.Optional[str] = None,
        environment: CodeCombatEnvironment = CodeCombatEnvironment.DEFAULT,
        username: typing.Union[str, typing.Callable[[], str]],
        password: typing.Union[str, typing.Callable[[], str]],
        timeout: typing.Optional[float] = 60,
    ):
        self._client_wrapper = AsyncClientWrapper(
            base_url=_get_base_url(base_url=base_url, environment=environment),
            username=username,
            password=password,
            httpx_client=httpx.AsyncClient(timeout=timeout),
        )
        self.auth = AsyncAuthClient(client_wrapper=self._client_wrapper)
        self.clans = AsyncClansClient(client_wrapper=self._client_wrapper)
        self.classrooms = AsyncClassroomsClient(client_wrapper=self._client_wrapper)
        self.stats = AsyncStatsClient(client_wrapper=self._client_wrapper)
        self.users = AsyncUsersClient(client_wrapper=self._client_wrapper)

    async def post_users_handle_o_auth_identities(
        self,
        handle: str,
        *,
        provider: str,
        access_token: typing.Optional[str] = OMIT,
        code: typing.Optional[str] = OMIT,
    ) -> UserResponse:
        """
        Adds an OAuth2 identity to the user, so that they can be logged in with that identity. You need to send the OAuth code or the access token to this endpoint. 1. If no access token is provided, it will use your OAuth2 token URL to exchange the given code for an access token. 2. Then it will use the access token (given by you, or received from step 1) to look up the user on your service using the lookup URL, and expects a JSON object in response with an `id` property. 3. It will then save that user `id` to the user in our db as a new OAuthIdentity. In this example, we call your lookup URL (let's say, `https://oauth.provider/user?t=<%= accessToken %>`) with the access token (`1234`). The lookup URL returns `{ id: 'abcd' }` in this case, which we save to the user in our db.

        Parameters:
            - handle: str. The document's `_id` or `slug`.

            - provider: str. Your OAuth Provider ID.

            - access_token: typing.Optional[str]. Will be passed through your lookup URL to get the user ID. Required if no `code`.

            - code: typing.Optional[str]. Will be passed to the OAuth token endpoint to get a token. Required if no `accessToken`.
        """
        _request: typing.Dict[str, typing.Any] = {"provider": provider}
        if access_token is not OMIT:
            _request["accessToken"] = access_token
        if code is not OMIT:
            _request["code"] = code
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"users/{handle}/o-auth-identities"),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(UserResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)


def _get_base_url(*, base_url: typing.Optional[str] = None, environment: CodeCombatEnvironment) -> str:
    if base_url is not None:
        return base_url
    elif environment is not None:
        return environment.value
    else:
        raise Exception("Please pass in either base_url or environment to construct the client")
